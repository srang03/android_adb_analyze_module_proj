## 1.1 연구 배경 및 필요성

[1단계: 문제의 심각성]

스마트폰을 이용한 불법 촬영이 국가 및 산업 안보를 위협하는 핵심적인 보안 위협으로 대두되고 있다. 정보 유출은 외부의 해킹 공격뿐만 아니라 내부자에 의해서도 발생하는데, 특히 내부자에 의한 위협은 "사전 탐지가 어렵고 피해 규모가 훨씬 크다"는 특징을 가진다(김령호, 2021). 실제로 Verizon의 데이터 유출 조사 보고서에 따르면, 전체 보안 규정 위반의 **34%가 내부자에 의해 발생**하는 것으로 나타났으며, 국내에서도 금융권의 대규모 개인정보 유출, 공공기관의 기밀 유출 등 내부자 소행의 심각한 보안 사고가 꾸준히 발생하고 있다.

이러한 내부자 정보 유출의 다양한 경로 중, 본 연구는 '스마트폰 사진 촬영'이라는 수단에 주목한다. 정부의 「제5차 산업기술의 유출방지 및 보호에 관한 종합계획」에 따르면, 2019년부터 2023년까지 적발된 산업기술 해외 유출 96건 중, '사진촬영'이 공식적인 유출 수단의 하나(6%)로 확인되었다(관계부처 합동, 2024). 비록 그 비율이 이메일(28%)이나 외부저장장치(42%)에 비해 낮아 보일 수 있으나, 이는 탐지가 매우 어려워 수면 위로 드러난 빙산의 일각일 가능성이 높다. 

실제로 같은 기간 산업기술 유출로 인해 추산되는 피해액은 약 24.8조원에 이르며(관계부처 합동, 2024), 기술유출 사건 중 내부인(전·현직 임직원)이 차지하는 비율이 90% 이상을 차지한다는 점에서(관계부처 합동, 2024) 내부자에 의한 스마트폰 촬영 위협의 심각성을 알 수 있다. 특히, 현장에서는 카메라 렌즈를 가리는 보안 스티커나 MDM 솔루션이 도입되어 있음에도 불구하고, 이를 우회하려는 시도가 끊이지 않아(김령호, 2021) 사후 탐지 기술의 중요성이 더욱 부각된다.

이러한 배경에서, 스마트폰 촬영 행위의 고유한 특성은 기존 보안 대응책의 한계를 더욱 명확히 드러낸다. 이메일 전송이나 외부저장장치 사용과 같은 전통적인 정보 유출 수단은 파일 시스템에 명백한 흔적을 남기는 반면, 스마트폰 촬영은 **순간적으로 발생하며 촬영된 이미지 파일의 삭제를 통해 증거 인멸이 매우 용이하다**는 특징을 가진다. 

따라서, 파일 아티팩트에 의존하는 기존 포렌식 기법으로는 탐지가 어려운 스마트폰 촬영 행위를 **시스템 레벨에서 자동으로 생성되는 로그 데이터를 통해 추적할 수 있는 신뢰성 있는 사후 탐지(Post-incident Detection) 방법론**의 개발이 절실히 요구된다. 이는 증거 인멸 이후에도 시스템에 잔존하는 미세한 흔적을 통해 촬영 행위 자체를 과학적으로 입증할 수 있는 보완적 수단으로서의 의미를 가진다.

[2단계: 기존 해결책의 한계]
현재 산업 현장에서는 이러한 위협에 대응하기 위해 여러 보안 수단을 적용하고 있다. 물리적 보안 조치인 보안 스티커는 손쉽게 우회할 수 있으며, MDM(Mobile Device Management) 솔루션은 높은 비용과 구성원의 프라이버시 침해 문제로 인해, 특히 개인 소유 기기를 업무에 활용하는 BYOD(Bring Your Own Device) 환경에서 실질적인 적용에 어려움을 겪는다.

또한, 사고 발생 후 분석에 사용되는 전통적인 디지털 포렌식 도구들은 대부분 분석 과정에서 '루팅(Rooting)'을 요구한다. 이는 기기의 보증을 무효화하고 새로운 보안 취약점을 야기할 수 있으며, 분석에 높은 비용과 전문 인력이 필요하여 신속한 초기 대응 수단으로는 한계가 명확하다. 이처럼 기존 대응책들은 우회 가능성, 프라이버시 침해, 실용성 제약 이라는 본질적인 문제점을 안고 있다.

[3단계: 새로운 대안의 등장과 '연구 공백(Research Gap)'제시]
이러한 한계를 극복하기 위한 대안으로 비루팅(Non-rooting) 환경에서 adb 명령어를 통해 접근 가능한 Android 시스템 로그를 활용하는 접근법이 새로운 가능성으로 주목 받고 있다. 선행 연구들은 특정 시스템 로그에서 카메라 사용과 관련된 이벤트 로그가 기록된다는 사실을 밝혀내며, 파일 없이도 행위를 추적할 수 있는 잠재력을 보여주었다.

구체적으로, **권혁철(2024)**은 ADB를 통해 수집 가능한 방대한 진단 로그를 체계적으로 분류하고 정규화하여 포렌식적 활용 가능성을 폭넓게 제시하였으며, **안원석 외(2025)**는 media.camera와 audio 로그를 중심으로 촬영 및 녹음 행위의 탐지 가능성을 확인하였다. 또한 **강예지 외(2021)**는 UsageStats라는 단일 로그의 심층 분석을 통해 사용자 행위 추적의 깊이를 더했다. **박은후(2020)**는 비루팅 환경에서 버그 리포트를 활용한 비휘발성 로그 분석 프로세스를 제안하였으며, **조재형(2016)**은 시스템 로그를 통한 공장초기화와 USIM 교체 등의 안티 포렌식 행위 탐지 가능성을 입증하였다.

하지만, 선행 연구들은 "특정 로그에서 관련 흔적을 발견할 수 있다"는 정성적(Qualitative)인 가능성 제시에 그치고 있다. 실제로 각 로그가 얼마나 정확하게 촬영을 탐지할 수 있는지에 대한 성능, 어떤 조건에서 탐지가 실패하는지에 대한 한계, 그리고 로그의 휘발성이 탐지율에 미치는 영향은 어느정도인지 대한 정량적(Quantitative)이고 체계적인 검증은 전무한 실정이다.
예를 들어, **박은후(2020)**의 비휘발성 로그 연구는 "사용자 행위를 파악할 수 있다"는 정성적 결과에 그쳤으며, **조재형(2016)**의 안티 포렌식 대응 연구도 "흔적을 발견할 수 있다"는 가능성 제시에 한정되었다. **안원석(2025)**의 최신 연구조차 "촬영 행위 탐지가 가능하다"는 개념적 접근에 머물러 있어, 실무 적용을 위한 정량적 성능 데이터는 전무한 상태이다.
즉, 실무에서 이 기술을 신뢰하고 적용하기 위해서 반드시 필요한 '성능 특성과 명확한 한계'에 대한 과학적 데이터가 부재한 상태이다.

## 1.2 연구 목적

따라서 본 연구는 **2장에서 규명한 연구 공백**인 '정량적 성능 및 한계 규명의 부재'를 해결하는 것을 핵심 목적으로 한다. 구체적으로, **카메라 촬영 탐지에 유효한 Android 시스템 로그들을 체계적으로 선별하고, 각 로그의 개별적인 탐지 성능**을 객관적으로 측정하며, 실무 적용의 명확한 한계점을 과학적으로 규명하고자 한다.

본 연구의 세 가지 핵심 목적은 다음과 같다.

1. **로그별 탐지 성능 정립**: 카메라 관련 행위 탐지에 유효한 핵심 Android 시스템 로그들을 체계적으로 선별하고, 각 로그의 개별적인 행위별 탐지 성능을 체계적으로 측정하며, 각 로그의 탐지 특성과 한계를 명확히 규명한다.

   이 접근법의 **이론적 근거**는 Android 시스템 로그의 생성 특성과 휘발성 차이에 기반한다. 각 로그는 카메라 사용의 서로 다른 측면을 기록하며(예: 하드웨어 접근, 앱 사용 패턴, 셔터음 처리 등), 시간 경과, 사용량 누적, 시스템 재부팅에 따라 각기 다른 휘발성 특성을 보인다. 이러한 로그별 특성 차이를 정량적으로 분석함으로써 실무적 활용 가이드라인을 제공할 수 있다.
2. **정량적 성능 측정**: 통제된 환경에서 **192세션의 실험(파일럿 테스트 32세션 + 본 실험 160세션)**을 통해 각 로그별 **행위 유형별 탐지 성능** 지표(카메라 사용 탐지 F1-Score, 카메라 촬영 탐지 F1-Score)를 과학적으로 측정하여, 기존 연구의 정성적 접근 한계를 극복한다.
3. **실무적 한계 규명**: 앱 아키텍처 차이와 로그 휘발성(재부팅, 시간 경과, 사용량 누적)이 탐지 성능에 미치는 영향을 정량적으로 분석하여, 해당 기술의 실무 적용 가능 범위와 명확한 사각지대를 제시한다.

## 1.3 연구 문제와 가설

상기 연구 목적을 달성하기 위해, 본 연구는 **3장의 192세션 통제 실험** (파일럿 테스트 32세션 + 본 실험 160세션)을 통해 다음과 같은 구체적인 연구 질문에 답하고자 한다.

**연구 문제 (Research Questions)**

- **RQ1 (행위 유형별 탐지 성능 측정)**: 각 Android 시스템 로그의 카메라 사용 탐지 성능과 카메라 촬영 탐지 성능은 어떤 차이를 보이는가? 즉, 각 로그가 특화된 탐지 영역과 성능 수준은 무엇인가?

- **RQ2 (앱 아키텍처 영향 분석)**: 앱 아키텍처 유형에 따라 각 시스템 로그의 탐지 성능에 어떤 차이가 있는가? 어떤 아키텍처에서 어떤 로그가 더 우수한 성능을 보이는가?

- **RQ3 (휘발성 조건 영향 분석)**: 로그 휘발성 조건에 따라 각 시스템 로그의 탐지 성능이 어떻게 변화하는가? 시간 경과, 사용량 누적, 재부팅이 각 로그에 미치는 영향의 정도는 어느 수준인가?

**핵심 변수의 개념적 정의**

본 연구의 가설 검증을 위해 사용되는 핵심 변수들의 개념적 정의는 다음과 같다:

- **탐지 분석 유형**: 동일한 시스템 로그를 '카메라 사용 탐지'와 '카메라 촬영 탐지'라는 두 가지 분석 목표에서 각각 평가하는 본 연구의 핵심 개념이다. 이는 각 로그가 **'카메라를 사용하되 촬영하지 않은 경우'**를 탐지하는 능력과 **'카메라를 사용하고 실제 촬영까지 수행한 경우'**를 구분 탐지하는 능력을 분리 측정하여, 로그별 특화된 강점을 정량적으로 규명하기 위한 방법론이다.

- **앱 아키텍처 유형**: 안드로이드 앱이 카메라 하드웨어에 접근하고 카메라 기능을 구현하는 기술적 방식의 분류 체계로, Android Developer Documentation의 공식 2가지 방식을 포렌식 관점에서 4가지 유형으로 세분화한 개발 분류이다. 이는 카메라 제어 방식, 이미지 저장 정책, 시스템 피드백 정책의 차이에 따라 시스템 로그 생성에 서로 다른 영향을 미치는 구조적 특성을 의미한다.

- **로그 휘발성 조건**: 시스템 로그의 보존 상태와 접근 가능성에 영향을 미치는 시간적, 사용량적, 시스템적 요인들의 조합으로, 2장 2.1.3절에서 제시한 로그 휘발성 이론에 기반한다. 이는 재부팅, 시간 경과, 사용량 누적 등의 실무적 제약 조건들이 탐지 성능에 미치는 영향의 정도를 의미한다.

**연구 가설 (Research Hypotheses)**

상기 개념적 정의를 바탕으로, RQ1-RQ3의 연구 질문에 답하기 위해 다음과 같은 통계적 가설을 설정하여 검증한다.

- **H1 (행위 유형별 탐지 성능 가설)**: 각 Android 시스템 로그는 카메라 사용 탐지 성능과 카메라 촬영 탐지 성능 간에 통계적으로 유의미한 차이를 보일 것이다. 특히, 각 로그는 고유한 특화된 탐지 영역을 가질 것이다.

  - *독립변수*: 탐지 분석 유형 (카메라 사용 탐지, 카메라 촬영 탐지)
  - *종속변수*: 탐지 성능 (F1-Score)
  - *검증 방법*: 로그별 대응표본 t-검정 (Paired t-test)
  - *이론적 근거*: **3장 행위 유형별 탐지 분석**에 따르면, 시스템 로그는 카메라 서비스 접근과 실제 미디어 생성의 서로 다른 단계를 기록하므로, '카메라 사용(비촬영)' 시나리오와 '카메라 사용+촬영' 시나리오에 대해 로그별로 특화된 탐지 영역이 존재할 것으로 예상된다.

- **H2 (앱 아키텍처 가설)**: 앱 아키텍처 유형에 따라 각 로그별 탐지 성능에 통계적으로 유의미한 차이가 있을 것이다. 특히, 각 아키텍처의 구체적 구현 차이(저장 정책, API 사용 방식, 시스템 피드백 패턴)에 따라 서로 다른 로그 생성 패턴을 보여 차별적인 탐지 성능을 나타낼 것이다.

  - *독립변수*: 앱 아키텍처 유형 (S1: 시스템 표준, S2: 인텐트 위임, S3: 앱 내장, S4: 시스템 피드백 우회)
  - *종속변수*: 탐지 성능 (F1-Score)
  - *검증 방법*: 일원분산분석 (One-way ANOVA)
  - *이론적 근거*: 각 아키텍처 유형은 **카메라 API 사용 방식, 이미지 저장 정책, 시스템 피드백 활용 패턴**에서 구체적인 차이를 보인다. 이러한 구현 차이에 따라 각 유형별로 서로 다른 시스템 로그 생성 패턴을 보이므로, 차별적인 탐지 성능을 유발할 수 있다.

- **H3 (휘발성 가설)**: 로그 휘발성 조건에 따라 각 로그별 탐지 성능에 통계적으로 유의미한 차이가 있을 것이다. V0(즉시) > V-Time(24시간) > V-Usage(간섭) > V-Event(재부팅) 순으로 성능이 저하될 것이다.

  - *독립변수*: 휘발성 조건 (V0, V-Time, V-Usage, V-Event)
  - *종속변수*: 탐지 성능 (F1-Score)
  - *검증 방법*: 일원분산분석 (One-way ANOVA) + 추세분석
  - *이론적 근거*: **2장 2.1.3절**에서 제시한 로그 휘발성 이론에 따라, 각 로그는 시간 경과, 사용량 누적, 시스템 재시작에 따라 서로 다른 휘발성 특성을 보이므로, 탐지 성능에 차별적인 영향을 미칠 수 있다.

#### **1.3.1 행위 유형별 탐지 성능의 분석 체계**

본 연구는 **RQ1**의 핵심 독립변수인 '탐지 분석 유형'을 정의하기 위해, 동일한 시스템 로그를 서로 다른 두 가지 분석 목표에서 평가하는 **행위 유형별 탐지 분석(Behavior-Type-Specific Detection Analysis)**을 개발한다.

**이론적 배경**: Android 시스템 로그는 카메라 관련 행위의 **서로 다른 단계**를 기록한다. 카메라 서비스 접근만 발생하는 경우(비촬영)와 카메라 서비스 접근 후 실제 미디어 파일 생성까지 수행하는 경우(촬영)는 시스템 내에서 구별되는 프로세스이며, 각 로그는 이 중 특정 시나리오에 더 특화된 정보를 담고 있을 것으로 예상된다.

**분석 유형 정의**: 

**유형 1: 카메라 사용 탐지**
- **정의**: '카메라를 사용하되 촬영하지 않은 경우'를 탐지하는 성능
- **실험 설계 대응**: 촬영N 시나리오 (카메라 앱 실행 → 10초간 확인 → 촬영하지 않고 종료)
- **Ground Truth**: 실제 카메라 앱 실행 시작/종료 시간 기록 및 촬영 행위 미발생 확인
- **측정 대상**: 카메라 서비스 접근은 발생했으나 실제 촬영은 수행하지 않은 시나리오의 식별
- **예상 특화 로그**: `media.camera`, `usagestats`, `activity` 등 서비스 접근 및 앱 사용 패턴 기록 로그

**유형 2: 카메라 촬영 탐지**  
- **정의**: '카메라를 사용하고 실제 촬영까지 수행한 경우'를 탐지하는 성능
- **실험 설계 대응**: 촬영Y 시나리오 (카메라 앱 실행 → 화면 확인 → 실제 촬영 1회 → 종료)
- **Ground Truth**: 실제 촬영 버튼 클릭 시점 기록 및 생성된 이미지 파일의 존재/생성시간 확인
- **측정 대상**: 카메라 서비스 접근 후 실제 미디어 파일 생성까지 완료된 시나리오의 식별
- **예상 특화 로그**: `audio`, `media.metrics`, `vibrator_manager` 등 촬영 행위 직접 증거 로그

**행위 유형별 분석의 방법론적 의의**: 이러한 구분을 통해 각 로그의 **특화된 탐지 영역**을 정량적으로 규명함으로써, 실무에서 "카메라 사용만 확인하면 되는지, 실제 촬영까지 확인해야 하는지에 따라 어떤 로그를 우선 분석해야 하는지"에 대한 과학적 가이드라인을 제공할 수 있다.

[REF: 3장 행위 유형별 탐지 분석 설계; 본 연구의 방법론적 개발]

#### **1.3.2 앱 아키텍처 유형의 분류 체계**

본 연구는 **H2 가설**의 핵심 독립변수인 '앱 아키텍처 유형'을 정의하기 위해, Android Developer Guide에서 제시하는 카메라 구현 방법론을 기반으로 **연구 목적에 맞는 분류 체계**를 개발한다.

**Android 공식 구분**: Android 개발 문서는 카메라 기능 구현을 크게 **두 가지 방식**으로 구분한다. (1) `MediaStore.ACTION_IMAGE_CAPTURE` 인텐트를 사용하여 기존 카메라 앱에 작업을 위임하는 방식과 (2) `CameraX` 또는 `Camera2` API를 사용하여 앱 내에서 직접 카메라를 제어하는 방식이다.

**선행연구의 실증적 근거**: **안원석 외(2025)**는 기본 카메라 앱(직접 API 호출)과 메신저 앱(인텐트 위임)이 `media.camera` 서비스 접근에서 서로 다른 패턴을 보임을 실증하였으며, **권혁철(2024)**은 앱 유형별로 시스템 로그 생성 패턴에 뚜렷한 차이가 있음을 확인하였다.

**본 연구의 세분화 논리**: Android 공식 분류를 포렌식 관점에서 세분화한다. 
- **(1) 인텐트 위임 방식**은 항상 시스템 카메라 앱에 완전히 의존하므로 앱에서 저장 정책이나 피드백 정책을 직접 제어할 수 없어 **단일 패턴(S2)**으로 분류한다. 
- **(2) 직접 API 방식**은 앱에서 **이미지 저장 정책**과 **시스템 피드백 정책**을 직접 제어 가능하므로, 각 정책 조합에 따라 서로 다른 로그 생성 패턴을 보이는 **3가지 하위 유형(S1, S3, S4)**으로 세분화한다: S1(표준 저장+표준 피드백), S3(앱 내부 저장+표준 피드백), S4(표준 저장+피드백 우회). 

**최종 4가지 분류**: 이러한 논리에 따라 총 **4가지 상호 배타적 유형**을 도출한다.

**분류 기준**: 카메라 제어 방식을 1차 기준으로, 직접 API 방식에 대해 이미지 저장 정책과 시스템 피드백 정책을 추가 기준으로 적용하여 4가지 상호 배타적인 유형으로 분류

| 유형 | 제어 방식 | 저장 정책 | 피드백 정책 |
|------|-----------|-----------|-------------|
| S1 | 직접 API | 표준 저장 | 표준 피드백 |
| S2 | 인텐트 위임 | 위임받은 앱 | 표준 피드백 |
| S3 | 직접 API | 앱 내부 저장 | 표준 피드백 |
| S4 | 직접 API | 표준 저장 | 피드백 우회 |

**S1 (시스템 표준 카메라 구현)**은 Android의 공식 카메라 API를 표준적인 방식으로 구현하는 유형이다. 이 유형은 `Camera2` 또는 `CameraX` API를 직접 호출하여 카메라 하드웨어를 제어하며, Android Developer Guide에서 권장하는 표준적인 이미지 저장 정책을 따른다. 

기술적으로는 카메라 세션을 직접 생성하고 관리하며, 촬영된 이미지는 시스템의 공용 저장소인 Pictures 디렉터리에 저장된다. Android 10 이후의 Scoped Storage 정책에 따라 `MediaStore.Images.Media.EXTERNAL_CONTENT_URI`를 통해 이미지를 등록하여 갤러리 앱에서 접근 가능하게 한다. 이 과정에서 `MediaStore`의 미디어 스캐닝 메커니즘이 자동으로 작동하여 새로 생성된 이미지 파일을 시스템에서 인식하고 색인화한다.

시스템과의 상호작용 측면에서는 `CAMERA` 권한을 필수적으로 요구하며, 이미지 저장 시 시스템의 표준 알림 메커니즘을 통해 사용자에게 촬영 완료를 알린다. 또한 `MediaActionSound` 클래스를 통한 표준 셔터음 재생이 기본적으로 활성화되어 있다. 

**대표 사례**: Samsung Galaxy 시리즈의 기본 카메라 앱 (`com.sec.android.app.camera`)이 이 유형의 전형적인 예시로, 시스템이 제공하는 모든 표준 카메라 기능과 저장 정책을 그대로 활용한다.

**S2 (인텐트 기반 위임 방식)**은 Android의 Intent 시스템을 활용하여 카메라 기능을 외부 앱에 완전히 위임하는 구현 유형이다. 이 방식은 `MediaStore.ACTION_IMAGE_CAPTURE` 인텐트를 발송하여 사용자 기기에 설치된 카메라 앱 중 하나가 실제 촬영 작업을 담당하도록 한다.

기술적 동작 과정을 살펴보면, 해당 앱은 카메라 하드웨어에 직접 접근하지 않고 `startActivityForResult()` 메서드를 통해 다른 앱으로 제어권을 완전히 넘긴다. 이때 사용자는 기본 카메라 앱의 인터페이스에서 촬영을 수행하며, 촬영 완료 후 원래 앱으로 돌아와 결과 데이터만을 받아 처리한다. 실제 카메라 하드웨어 접근, 이미지 생성, 파일 저장은 모두 위임받은 카메라 앱의 구현 방식을 따른다.

시스템과의 상호작용에서 주목할 점은 Intent를 발송하는 앱 자체는 `CAMERA` 권한을 필요로 하지 않는다는 것이다. 대신 Activity 생명주기 관리와 Intent를 통한 앱 간 데이터 전달에 의존한다. 또한 촬영된 이미지의 저장 위치와 `MediaStore` 등록 여부는 위임받은 카메라 앱의 정책에 의해 결정된다.

**대표 사례**: 메신저 앱들의 사진 첨부 기능이 이 유형의 대표적인 예시이며, 특히 KakaoTalk (`com.kakao.talk`)의 채팅방에서 카메라 아이콘을 터치할 때 나타나는 "카메라로 촬영" 옵션이 이에 해당한다.

**S3 (앱 내장 카메라 구현)**은 카메라 API를 직접 사용하되 앱의 특화된 목적에 맞게 저장 정책을 변경한 구현 유형이다. 이 유형은 S1과 동일하게 `Camera2` 또는 `CameraX` API를 직접 호출하여 카메라 하드웨어를 제어하지만, 촬영된 이미지를 시스템의 공용 갤러리가 아닌 앱 전용 저장소에 보관한다.

기술적으로는 카메라 세션 생성과 이미지 캡처 과정이 S1과 유사하지만, 저장 위치에서 핵심적인 차이를 보인다. 촬영된 이미지는 `Context.getExternalFilesDir()` 메서드를 통해 획득한 앱 전용 외부 저장소 디렉터리나, `Context.getCacheDir()`를 통한 캐시 영역에 저장된다. 이렇게 저장된 파일들은 시스템의 `MediaStore` 데이터베이스에 등록되지 않으며, 따라서 일반적인 갤러리 앱에서는 접근할 수 없다.

이러한 저장 방식의 변경은 앱의 특화된 용도에 기인한다. 메신저 앱의 경우 촬영한 사진을 즉시 대화 상대에게 전송하는 것이 주목적이므로, 기기의 갤러리에 영구 보존할 필요가 없다. 소셜미디어 앱의 스토리 기능 역시 일시적인 콘텐츠 생성이 목적이므로 유사한 저장 전략을 사용한다.

시스템과의 상호작용에서는 S1과 마찬가지로 `CAMERA` 권한을 필요로 하지만, `MediaStore` 등록 과정이 생략되므로 미디어 스캐닝 관련 시스템 알림이 발생하지 않는다. 또한 앱별로 특화된 이미지 처리 파이프라인을 구현할 수 있어, 필터링, 압축, 포맷 변환 등의 추가 처리가 가능하다.

**대표 사례**: Telegram Messenger (`org.telegram.messenger`)의 인앱 카메라 기능이나 Instagram의 스토리 촬영 기능 등이 이 유형에 해당하며, 촬영한 이미지를 앱 내부에서만 관리하고 사용한다.

**S4 (시스템 피드백 우회 구현)**은 카메라 API를 직접 사용하면서도 Android 시스템의 표준 피드백 메커니즘을 의도적으로 수정하거나 우회하는 구현 유형이다. 이 유형은 S1과 동일하게 `Camera2` 또는 `CameraX` API를 사용하여 카메라 하드웨어를 직접 제어하지만, 촬영 과정에서 발생하는 시스템의 표준적인 알림이나 피드백을 최소화한다.

가장 대표적인 기술적 특징은 무음 촬영 구현이다. 일반적인 Android 카메라 앱은 `MediaActionSound` 클래스를 통해 촬영 시 셔터음을 자동으로 재생하지만, S4 유형의 앱은 이 클래스의 `play()` 메서드 호출을 생략하거나, `AudioManager.setStreamVolume()` 메서드를 사용하여 시스템 미디어 음량을 일시적으로 0으로 조정함으로써 무음 촬영을 구현한다. 일부 앱은 `AudioManager.RINGER_MODE_SILENT` 설정을 활용하기도 한다.

이미지 저장 정책은 S1과 유사하게 시스템의 표준 Pictures 디렉터리를 사용하며 `MediaStore`에도 정상적으로 등록하지만, 저장 과정에서 발생하는 시스템 알림이나 미디어 스캐닝 완료 알림 등을 최소화하려는 구현 특성을 보인다. 이는 주로 촬영 행위의 은밀성을 높이기 위한 목적으로 사용된다.

시스템과의 상호작용에서는 `CAMERA` 권한을 정상적으로 요청하고 사용하지만, 오디오 시스템 설정을 직접 조작하는 추가적인 권한(`MODIFY_AUDIO_SETTINGS`)을 요구하는 경우가 많다. 또한 일반적인 카메라 앱과는 다른 오디오 서비스 접근 패턴을 보이며, 이는 시스템 로그에서 식별 가능한 특징으로 나타난다.

**대표 사례**: "무음 카메라" 또는 "Silent Camera"라는 이름으로 배포되는 다수의 앱들이 이 유형에 해당하며, 그 중 하나인 Silent Camera by NGS (`com.aprogrammer.silentcamera`)가 대표적인 예시이다.

**분류의 이론적 근거**

상기 4가지 앱 아키텍처 유형은 각각 Android 시스템과의 상호작용에서 구별되는 패턴을 보이며, 이는 시스템 로그 생성에 직접적인 영향을 미친다. 

**S2 (인텐트 위임)**는 다른 유형들과 근본적으로 다른 로그 생성 패턴을 나타낸다. 카메라 하드웨어에 직접 접근하지 않고 Intent 메커니즘을 통한 앱 간 통신에 의존하므로, `activity` 로그에서 특징적인 Activity 전환 기록과 Intent 데이터 전달 흔적이 나타난다. 반면 `media.camera` 서비스에서는 간접적인 접근 패턴만 기록된다.

**S1, S3, S4**는 모두 `Camera2/CameraX` API를 직접 사용하므로 `media.camera` 서비스에서 유사한 클라이언트 연결 및 세션 관리 로그를 생성한다. 하지만 이미지 저장 정책과 시스템 피드백 처리 방식의 차이로 인해 다른 시스템 로그에서는 구별되는 패턴을 보인다.

**S1**은 `MediaStore` 등록 과정에서 미디어 스캐닝 관련 로그와 시스템 알림 로그가 함께 생성되며, 표준 셔터음 재생으로 인한 `audio` 서비스 로그가 정상적으로 기록된다. **S3**는 앱 내부 저장으로 인해 `MediaStore` 등록 관련 로그가 누락되지만 표준 `audio` 피드백은 유지된다. **S4**는 `MediaStore` 등록은 수행하되 `audio` 서비스에서 비정상적인 음량 조작 패턴이나 `MediaActionSound` 비활성화 흔적이 나타난다.

이러한 시스템 상호작용의 구체적인 차이로 인해 각 아키텍처 유형별로 차별적인 로그 패턴이 생성되며, 이는 포렌식 분석에서 탐지 성능의 차이로 나타날 것으로 예상된다.

[REF: Android Developers. "Take photos" 및 "CameraX overview" 문서; 안원석 외. (2025). 비루팅 환경에서 ADB를 활용한 안드로이드 카메라 및 오디오 행위 탐지 연구; 권혁철. (2024). ADB 기반 Android 진단 로그의 체계적 분류 및 포렌식 활용 방안; 본 연구에서 포렌식 관점으로 재분류]

#### **1.3.3 휘발성 조건의 이론적 근거**

본 연구는 **H3 가설**의 핵심 독립변수인 '로그 휘발성 조건'을 선행 연구에서 확인된 Android 시스템 로그의 특성을 기반으로 **4단계 실험 조건**으로 체계화한다.

**이론적 배경**: **박은후(2020)**와 **조재형(2016)**의 연구에 따르면, Android 시스템 로그는 메모리 기반 순환 버퍼 방식으로 저장되어 시간 경과, 사용량 누적, 시스템 재시작에 따라 휘발성을 보인다. **Android Developer Documentation**에서도 logcat 버퍼의 크기 제한과 순환 방식을 명시하고 있어, 이러한 특성이 실제 포렌식 분석에서 중요한 제약 요인이 됨을 확인할 수 있다.

**본 연구의 4단계 조건 설정**: 위의 이론적 배경을 바탕으로, 실무에서 직면할 수 있는 시나리오를 다음과 같이 체계화한다.

**V0 (기준 조건)**은 휘발성 요인의 간섭이 최소화된 이상적인 실험 조건을 의미한다. 카메라 행위 완료 직후 10초 이내에 즉시 로그를 수집함으로써, 로그가 생성된 직후 최대 정보량을 보존하고 있는 상태에서의 기준 성능(Baseline)을 측정한다. 

이 조건은 시스템 로그의 고유한 탐지 능력을 순수하게 평가하기 위한 통제 조건으로 기능하며, 다른 모든 휘발성 조건들과의 비교 기준점을 제공한다. 실무적으로는 사고 발생 즉시 신속한 초기 대응이 가능한 이상적인 포렌식 환경을 시뮬레이션한다.

**V-Time (시간 경과 조건)**은 자연적인 시간 흐름이 로그 보존 상태에 미치는 영향을 측정하는 조건이다. 동일한 카메라 행위에 대해 24시간의 자연적 경과 시간을 두고 동일한 로그를 재수집하여, 시간에 따른 자연적 로그 소실 효과를 정량적으로 분석한다.

이 조건의 설정 근거는 `usagestats`와 같은 서비스가 24시간 보존 정책을 가지고 있다는 선행연구 결과와, 실제 포렌식 현장에서 사고 발생과 분석 시작 사이에 발생하는 시간적 지연을 반영한 것이다. 특히 메모리 기반 순환 버퍼의 자연적 순환 주기와 시스템의 일반적 사용 패턴이 로그 보존에 미치는 복합적 영향을 측정할 수 있다.

**V-Usage (사용량 누적 조건)**는 집중적인 시스템 사용이 순환 버퍼 기반 로그의 덮어쓰기에 미치는 영향을 검증하는 조건이다. 카메라 행위 완료 후 체계적인 2단계 간섭 시나리오를 수행한다: (1) 일반적 앱 사용 패턴(브라우저 검색, 갤러리 사진/동영상 확인, SNS 메시지 송수신), (2) 추가 카메라 세션 수행(4개 앱에서 각각 카메라 실행→촬영→종료 반복)을 통해 로그 버퍼의 인위적 포화상태를 조성한다.

이러한 간섭 시나리오는 실제 사용자의 일상적 스마트폰 사용 패턴을 모사하여 현실적인 조건에서의 로그 소실 정도를 측정한다. 특히 `audio`, `media.metrics` 등 순환 버퍼 크기 제한이 있는 로그들이 사용량 증가에 따라 얼마나 빠르게 덮어쓰여 소실되는지를 정량적으로 규명할 수 있다.

**V-Event (시스템 재시작 조건)**는 시스템 재부팅이라는 가장 극단적인 휘발성 요인이 메모리 기반 로그에 미치는 완전 소실 효과를 검증하는 조건이다. 카메라 행위 완료 후 즉시 시스템 재부팅을 수행하고, 재부팅 완료 후 5분간의 부팅 프로세스 안정화 대기 시간을 거쳐 로그를 수집한다.

이 조건은 메모리 기반 로그 데이터의 본질적 한계를 명확히 규명하고, 재부팅 후에도 생존하는 지속성 로그(`usagestats` 등)와 완전히 소실되는 휘발성 로그(`media.camera`, `audio` 등)를 구분하는 데 중요한 역할을 한다. 실무적으로는 용의자가 의도적으로 기기를 재부팅하는 안티 포렌식 상황이나, 배터리 방전으로 인한 비의도적 재시작 등 극한 상황에서의 증거 보존 가능성을 과학적으로 평가할 수 있게 한다.

**가설적 성능 순서**: V0 > V-Time > V-Usage > V-Event 순으로 탐지 성능이 저하될 것으로 예상한다. 이는 휘발성 요인의 강도가 순차적으로 증가하는 논리적 순서에 기반한다.

**실무적 의의**: 각 조건은 실제 포렌식 현장에서 조사관이 직면할 수 있는 시간적 제약과 증거 보존 상태를 반영하여, 해당 기술의 실무 적용 가능 범위를 과학적으로 규명하는 데 사용된다.

[REF: 박은후. (2020). 데이터 획득방법에 따른 안드로이드 비휘발성 로그의 포렌식 분석 프로세스 설계; 조재형. (2016). 안드로이드 스마트폰 시스템 로그 분석 연구; Android Developer Documentation. "Logcat Command-line Tool"]

## 1.4 연구의 범위 및 제한점

본 연구는 명확하고 통제된 분석을 통해 과학적 결론을 도출하기 위해, 다음과 같이 연구의 범위를 명확히 설정한다. 이는 동시에 본 연구 결과가 적용될 수 있는 조건과 그 한계를 규정한다.

- 1.4.1 분석 대상 환경 (OS 및 기기)

  - 범위: 연구의 재현성 확보와 변수 통제를 위해, 분석 환경은 Android 15 운영체제가 탑재된 Samsung Galaxy S24 Ultra 단일 기종으로 한정한다. 안드로이드 생태계는 제조사별로 로그 생성 및 관리 정책이 상이한 '파편화(Fragmentation)' 특성을 가지므로 (권혁철, 2024), 전 세계 시장 점유율이 가장 높은 삼성 기기를 분석 대상으로 선정하는 것은 연구 결과의 실무적 파급력을 극대화하는 합리적인 선택이다. 본 연구는 안드로이드의 공식 진단 도구(adb, dumpsys 등)가 특정 주요 제조사 환경에서 어떻게 작동하는지를 심층 분석하는 것을 목표로 한다.
  - 제한점: 본 연구의 결과는 특정 OS 버전과 제조사에 강하게 의존한다. 따라서 타 제조사(예: Google, Xiaomi)의 기기나 다른 Android OS 버전에서는 로그의 구조, 내용, 보존 정책(예: Logcat 버퍼 크기)이 상이할 수 있으므로, 본 연구에서 도출된 시그니처나 성능 측정치가 동일하게 적용되지 않을 가능성이 높다. 본 연구는 향후 타 제조사로 확장될 수 있는 **기반 연구(Foundational Research)**로서의 성격을 가지며, 그 결과의 일반화에는 명백한 제약이 따른다.
- 1.4.2 분석 대상 행위 (사진 촬영)

  - 범위: 본 연구는 사용자의 다양한 미디어 기록 행위 중 **'카메라를 이용한 사진 촬영(Still Image Capture)'**과 그 선행 행위인 **'카메라 앱 사용(Camera App Usage)'**에 대한 탐지에 집중한다. 특히, **이중 분석 프레임워크**를 통해 "카메라 사용" 탐지와 "카메라 촬영" 탐지를 분리하여 각 로그의 특화된 탐지 영역을 정밀하게 규명한다. 이는 디지털 포렌식 관점에서 로그 생성 패턴이 명확하게 구분되는 단발성(Discrete) 이벤트에 대한 탐지 방법론을 우선적으로, 그리고 깊이 있게 정립하기 위함이다.
  - 제한점:'동영상 촬영(Video Recording)'은 본 연구의 범위에서 명시적으로 제외한다. 동영상 촬영은 사진 촬영과 달리, 녹화 시간 동안 MediaCodec, MediaMuxer 등 미디어 처리 컴포넌트와 관련된 지속적이고(Continuous) 반복적인 로그 스트림을 생성한다. 이는 단발성 이벤트인 사진 촬영과는 로그 시그니처의 패턴과 복잡성 면에서 근본적인 차이가 있어, 별도의 독립적인 연구를 요구한다. 동영상 촬영 시 발생하는 대량의 로그가 본 연구의 분석 대상인 사진 촬영 로그의 잔존성에 미치는 영향은, 본 연구의 **RQ2(영향 요인 분석)**에서 다루는 '로그 휘발성'의 중요한 분석 요소 중 하나이다.
- 1.4.3 분석 대상 애플리케이션 (4가지 아키텍처)

  - 범위: 카메라 기능 구현 방식의 기술적 차이를 대표하는 4가지 아키텍처 유형의 애플리케이션을 분석 대상으로 선정한다. 이는 Android 공식 개발자 문서에서 제시하는 카메라 기능 구현 표준을 기준으로 분류되었으며 (세부 근거는 3.2절에서 상술), 기술적으로 유의미한 차이를 보이는 대표 사례들을 통해 방법론의 강건성(Robustness)을 검증하고자 한다.
  - 제한점: 선정된 4가지 유형 외에 비표준적인 방식으로 카메라 하드웨어에 접근하거나, 로그 생성을 의도적으로 회피하도록 설계된 안티-포렌식(Anti-Forensics) 앱에 대해서는 본 연구의 탐지 방법론이 유효하지 않을 수 있다.
- 1.4.4 분석 대상 데이터 (시스템 로그)

  - 범위: 비루팅 환경에서 adb 명령어로 접근 가능하며 카메라 행위 분석과 직접적인 관련성이 높은 핵심 Android 시스템 로그들을 분석 대상으로 한정한다. 구체적인 로그 선별 과정과 선정 기준은 **3장 3.3절**에서 체계적으로 기술한다.
  - 제한점: 본 연구의 탐지 방법론은 상기한 특정 시나리오 해결을 위해 의도적으로 파일 시스템 아틴팩트(이미지 파일, EXIF 등)를 탐지 증거에서 배제한다. 파일 아틴팩트는 실험의 '정답(Ground Truth)'을 확립하는 데에만 사용된다. 이는 시스템 로그의 독립적인 증거 능력을 과학적으로 검증하기 위함이나, 역으로 파일이 온전히 존재하는 일반적인 상황에서는 파일 기반 포렌식 기법을 병행하는 것이 더 높은 신뢰도와 탐지율을 보일 수 있음을 의미한다. 본 연구의 결과는 기존 기법을 대체하는 것이 아닌, 기존 기법이 실패하는 지점을 보완하는 보조적 수단으로서의 의의가 있다.

## 1.5 논문의 구성

**본 논문은 총 5개의 장으로 구성된다.**

* **제1장**에서는 연구의 배경과 필요성을 제시하고, 연구 목적, 연구 문제 및 가설, 연구의 범위를 설정한다.
* **제2장**에서는 Android 로그 시스템과 디지털 포렌식 관련 이론적 배경을 고찰하고, 선행 연구들을 비판적으로 검토하여 본 연구의 학술적 위치와 독창성을 설명한다.
* **제3장**에서는 연구 문제를 검증하기 위한 체계적인 실험 설계와 데이터 수집 절차를 기술한다. 구체적으로, 핵심 독립 변수인 '앱 아키텍처'를 정의하고, '분석 대상 로그'를 과학적인 절차에 따라 선별하며, **192세션의 행위 유형별 분석 기반 실험 설계**와 **효율적 실험 전략**(V0-V-Time 연계, V-Usage 연속성으로 35% 시간 단축)을 상세히 제시한다.
* **제4장**에서는 **192세션의 실험 결과**를 바탕으로, 각 시스템 로그의 **행위 유형별 탐지 성능**(카메라 사용 vs 카메라 촬영)을 심층적으로 분석하고 통계적으로 검증한다. 이를 통해 연구 가설의 채택 여부를 논하고, 앱 아키텍처 및 로그 휘발성이 각 로그의 특화된 탐지 성능에 미치는 영향을 규명하며, 발생한 오류의 원인을 분석한다.
* **제5장**에서는 전체 연구 결과를 요약하고, 그 결과를 바탕으로 학술적·실무적 시사점을 논의한다. 마지막으로, 본 연구가 가진 명확한 한계점을 기술하고, 이를 극복하기 위한 향후 연구 방향을 제안하며 논문을 마무리한다.
